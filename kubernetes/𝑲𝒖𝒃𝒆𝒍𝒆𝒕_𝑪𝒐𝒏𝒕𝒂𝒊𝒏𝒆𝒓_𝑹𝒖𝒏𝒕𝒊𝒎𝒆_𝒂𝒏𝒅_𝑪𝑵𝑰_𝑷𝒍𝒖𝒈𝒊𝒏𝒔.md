ğ‘²ğ’–ğ’ƒğ’†ğ’ğ’†ğ’•, ğ‘ªğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’†ğ’“ ğ‘¹ğ’–ğ’ğ’•ğ’Šğ’ğ’† ğ’‚ğ’ğ’… ğ‘ªğ‘µğ‘° ğ‘·ğ’ğ’–ğ’ˆğ’Šğ’ğ’” - ğ’‰ğ’ğ’˜ ğ’•ğ’‰ğ’†ğ’š ğ’‚ğ’ğ’ ğ’”ğ’•ğ’Šğ’•ğ’„ğ’‰ğ’†ğ’… ğ’•ğ’ğ’ˆğ’†ğ’•ğ’‰ğ’†ğ’“ ğŸ¤” â˜¸ 

Kubernetes uses containerd as one of the CRI plugin to manage the full container lifecycle, importing OCI compliant images while the networking within pod is taken care by the k8s CNI plugin 

Let's understand what happens behind a pod creation :-

- Kubelet calls the cri plugin, via the CRI runtime service API, to create a pod

- CRI uses containerd internal to create and start a special pause container (the sandbox container) and put that container inside the podâ€™s cgroups and namespace 

- CRI configures the podâ€™s network namespace using CNI

- Kubelet subsequently calls the cri plugin, via the CRI image service API, to pull the application container image

- CRI further uses containerd to pull the image if the image is not present on the node.

- Kubelet then calls cri, via the CRI runtime service API, to create and start the application container inside the pod using the pulled container image

- CRI finally uses containerd internal to create the application container, puts it inside the podâ€™s cgroups and namespace, then to start the podâ€™s new application container. 

- After these steps, a pod and its corresponding application container is created and running.


Ref - https://github.com/containerd/cri/blob/v1.11.1/docs/architecture.md

![alt text](ğ‘²ğ’–ğ’ƒğ’†ğ’ğ’†ğ’•_ğ‘ªğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’†ğ’“_ğ‘¹ğ’–ğ’ğ’•ğ’Šğ’ğ’†_ğ’‚ğ’ğ’…_ğ‘ªğ‘µğ‘°_ğ‘·ğ’ğ’–ğ’ˆğ’Šğ’ğ’”.jpg "ğ‘²ğ’–ğ’ƒğ’†ğ’ğ’†ğ’•, ğ‘ªğ’ğ’ğ’•ğ’‚ğ’Šğ’ğ’†ğ’“ ğ‘¹ğ’–ğ’ğ’•ğ’Šğ’ğ’† ğ’‚ğ’ğ’… ğ‘ªğ‘µğ‘° ğ‘·ğ’ğ’–ğ’ˆğ’Šğ’ğ’” - ğ’‰ğ’ğ’˜ ğ’•ğ’‰ğ’†ğ’š ğ’‚ğ’ğ’ ğ’”ğ’•ğ’Šğ’•ğ’„ğ’‰ğ’†ğ’… ğ’•ğ’ğ’ˆğ’†ğ’•ğ’‰ğ’†ğ’“")
